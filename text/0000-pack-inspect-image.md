# Meta
[meta]: #meta
- Name: Inspect Image
- Start Date: 2019-04-25
- CNB Pull Request: (leave blank)
- Supersedes: N/A

# Summary
[summary]: #summary

An `inspect-image` command will be added to the `pack` CLI, allowing buildpack users to easily view metadata about an image generated by the Cloud Native Buildpack Lifecycle. The command will print the stack ID, stack metadata (run-image and run-image-mirrors), the buildpacks that contributed to the image, the bill of materials, and the processes types.

# Motivation
[motivation]: #motivation

The spec makes clear that auditability is one motivations for generating a bill-of-materials (BOM) from the build plan entry claims. However there is no easy way for users to discover or read this file. We should provide easy access to this information to enable auditing. This RFC proposes exporting this information into an image label and providing a way to discover and view this information in `pack`. For example, if I have build a java app a java buildpack(s) I may want to know which JRE was added to the image. This type of information will make buildpacks less mysterious and help users know what they are running and decide when to rebuild.

Beyond the BOM, there is other image metadata that, as a user of buildpacks, I would like easy access to. I may want to know what process types are available and what commands are associated with them. Knowing which run-image sha a particular image was based on can help users decide when to rebase. Knowing which buildpacks and version created an image can be useful for tracing the history of an image, recreating a build, or deciding when to rebuild. Finally, if I wish to rebase my app it is informative to know what run-image-mirrors might be selected (included those from the local pack config).

# What it is
[what-it-is]: #what-it-is

`pack inspect-image` command will provide the following information about the image

```
$ pack inspect-image <image-ref>

Stack ID: some.stack.id
Base:
    Image: run/image:tag
    Digest: sha256:9ccf0c97be7d
    Top Layer: sha256:3637529ca
Stack:
  Run Image: run/image:tag
  Run Image Mirrors:
    registry1.example.com/run/image:tag (user-configured)
    registry2.example.com/run/image:tag
Processes:
    TYPE       COMMAND
    web        web command
    worker     worker command
Contributing Buildpacks:
    NAME                VERSION
    buildpack.id        0.1.0
    other.buildpack     2.0.0

Bill of Materials:

  some-dependency:
    version: "some version"
  other-dependency
    version: "other version"
    metadata:
      some-key: "some-value"
      structured-data:
        foo: "bar"
        blah: ["blah", "blah"]
```

By default the `pack` will assume it is inspecting a daemon image. `pack inspect-image <image-ref> --remote` will inspect an image in a registry.

The "Base Image" section refers to the specific run image that was used during build, the "Stack" section includes metadata that may be used during a `pack rebase`

# How it Works
[how-it-works]: #how-it-works

`exporter` will add the bill-of-materials and the process types to the `io.buildpacks.lifecycle.metadata` label by adding `bom` and `processes` keys respectively.

`pack` will read all necessary information from the metadata label and display it to the user. 

# Drawbacks
[drawbacks]: #drawbacks

* Given that the BOM is not guaranteed to be comprehensive, users may be confused if dependencies that are added to the final image are not displayed in the Bill of Materials.
* Give that the BOM is not currently displayed anywhere. not all buildpacks are writing metadata to the BOM. If most buildpacks do not add entry claims with metadata, the Bill of Materials section of the output may be useless and/or actively misleading
* The two types of run image information may be confusing.
* The BOM does not currently associate dependencies with the buildpacks that contributed them.
* build plan entries are primarily functional, if buildpack authors do not explicitly consider the BOM, the fields they add may not be friendly to human eyes

# Alternatives
[alternatives]: #alternatives

Currently the image metadata contains all the layer metadata generated during build. This could be displayed instead of the BOM. The advantages to using the layer metadata are
* all of the buildpacks currently provide layer metadata
* the layer metadata is already stored in a way that associates it with the contributing buildpack
* using layer metadata would allow us to tell advanced users specifically which layers dependencies live in if we wished to at a later date

If we chose to use the layer metadata instead, I would propose removing the `[bom]` section from the image `metadata.toml` file, given that it currently serves no compelling purpose.

The problem with either of these approaches is that buildpack authors are likely to view both the build plan entry claims and the layer metadata from a functional rather than an informative perspective. Data in these field may not be human friendly. 

# Unresolved Questions
[unresolved-questions]: #unresolved-questions

- Should we add the buildpack id and version to the BOM entries?
- Is there a better format for the BOM output than YAML? TOML would be in keeping with our ecosystem but it's harder to read.
